# 10. 웹 캐싱 기법



[TOC]





## 1. 웹 캐싱



`웹 캐싱` 

- 웹 사용자에 의해 빈번히 요청되는 데이터를 사용자와 지리적으로 가까운 웹캐시 서버에 보관해 빠른 서비스를 가능하게 하는 기법
- *웹서버, *프락시 서버에 의해 이루어진다.



`프락시 서버` 

- 웹 사용자에 대한 서비스 지연시간을 줄이기 위해 사용
- 네트웨크의 대역폭 절약과 함께 웹서버 부하를 줄이는 역할



`역방향 프락시 캐시`

- 웹서버 쪽에 사용되는 캐시로, 웹서버의 객체들을 캐싱하여 서버의 부하를 직접적으로 줄이는 역할을 한다.
- 웹 사용자의 지연시간을 줄이는 역할을 한다.



`교체 알고리즘`

- 한정된 캐시 공간에서 사용자의 요청을 지속적으로 처리하기 위해 어떠한 객체를 삭제할지 온라인으로 결정하는 것



`일관성 유지 기법`

- 사용자가 요청한 웹 객체가 캐싱되어 있는 경우 이 객체가 근원지 서버에 있는 객체와 동일한지 확인하여 사용자에게 최신의 정보를 전달하는 기법
- 전통적인 컴퓨터 시스템에서는 중요한 요소였지만, 현대의 웹캐시에서는 크게 문제를 야기하지 않음





## 2. 웹 캐시의 교체 알고리즘

`캐시 교체 알고리즘` 

- 미래의 참조를 알지 못하는 상태에서 보관할 객체와 삭제할 객체를 동적으로 결정하는 온라인 알고리즘
- 객체의 크기와 인출 비용이 균일하지 않아 설계에 어려움이 따른다.
- 근원지 서버의 위치 및 특성에 따라 캐시를 읽어오는 비용이 다르기도 하고, URL에 대응하는 단위별로 캐싱이 이루어지기 때문에 캐싱 단위가 다르다.
- 이와 같은 *이질성(객체를 캐시로 읽어오는 비용)을 고려해야한다.



### 2-1. 교체 알고리즘의 성능 척도

`알고리즘 목표에 따른 고려 사항`

1. **참조 가능성** 이 목표라면, `캐시 적중률`을 높여야 한다.
2. **참조가능성**과 **이질성** 둘을 모두 고려한다면, *`비용 절감률`을 높여야 한다.
   - 객체의 비용 = 객체의 크기 => `바이트 절감률` 과 동일
   - 객체의 비용 = 객체의 인출 지연시간 => `지연 감소율` 과 동일

> 캐시 적중률 : 사용자의 총 요청 중에서 캐시에서 적중되어 서비스된 요청의 비율
>
> 비용 절감율 : 객체가 캐시에 없을 때와 있을때 걸리는 요청의 시간 차이의 비율
>
> 바이트 적중률 : 사용자에 의해 요청된 총 바이트 중에서 캐시에 이미 존재해서 근원지 서버에서 받아올 필요가없는 바이트 수의 비율
>
> 지연 감소율 : 캐시가 없을 경우의 지연시간 중 캐시가 있음으로 인해 줄어드는 지연시간의 비율
>
> 자세한 내용과 식은 p.266



### 2-2. 참조 가능성 예측

참조 가능성을 얼마나 잘 예측하느냐에 따라 효율성이 좌우되며, 캐시 내의 객체를 평가하는 일반적인 방법은 과거의 참조 기록에 의한 방법이다.



#### 캐싱 기법

`LFU(Least Frequency Used)`

- 참조 횟수가 가장 적은 객체를 캐시에서 삭제하는 방법
- 과거에만 굉장히 자주 쓰인 객체가 있다면, 최근부터 쓰이기 시작한 객체에 대해서는 캐싱하지 않는다는 단점!



`LRU(Least Recently Used)`

- 최근에 참조되지 않은 객체를 삭제하는 방법
- 최근 참조기록만 가지고 판단하기 때문에, 자주 참조되는 객체와 그렇지 않은 객체를 구분할 수 없다는 단점!



`LRU-K`

- 최근 K 번째 참조관 시각에 의거해 가치를 평가하는 방법
- 최근 K-1번 참조된 시점들은 무시된다는 단점!



`LRFU(Least Recently Frequency Used)`

- 각각의 참조시점을 그 최근성에 근거하여 고려하는 방법으로, 최근의 참조일수록 기여도를 높게 계산한다.
- 참조기여도(pi) 를 계산할 때 모든 과거 참조시점과 참조횟수를 다 이용한다.
- 과거 시점에서의 각각의 참조가 객체의 가치를 높이는 데 기여하는 바를 각 시점의 최근성에 근거해 계산하고 이를 더 하는 것이다.





#### 참조 가능성 평가

`시간 지역성` : 다시 참조될 가능성이 높다는 점

`객체의 인기도` : 참조 횟수가 많을 수록 또 다시 참조될 가능성이 높다는 점





### 2-3. 객체의 이질성에 대한 고려

7~8장 페이징과 같은 전통적은 캐싱 환경에서는 객체들의 크기가 모두 동일하기 때문에, 참조 가능성만을 고려하면 된다. 하지만 웹 캐싱에서는 객체들의 크기가 다른 이질적 환경이기 때문에 객체의 크기와 인출 비용을 고려한 합리적 평가가 필요하다.



### 2-4. 알고리즘의 시간 복잡도

시간복잡도가 O(n)이라면 캐싱 시스템에 대한 부담이 너무나 크다. 일반적으로 캐시 운영에 드는 시간이 O(logn)을 넘지 않는 것이 바람직하다.

`LRU` 알고리즘의 경우 참조된 시각을 기준으로 객체의 가치를 일렬로 세워놓고 새롭게 참조된 객체만 가치가 가장 높은 위치로 옮겨주면 되므로 리스트 자료구조를 통해 O(1)의 시간 복잡도로 구현이 가능하다.

하지만 이외의 알고리즘들은 새롭게 참조된 객체의 가치에 맞는 위치를 찾아주는 연산이 필요하고, 이때 `힙`을 사용하여 O(logn)의 시간 복잡도에 각종 캐시 연산을 구현한다.



![image-20210705211752572](C:\Users\multicampus\AppData\Roaming\Typora\typora-user-images\image-20210705211752572.png)





## 3. 웹캐시의 일관성 유지 기법

캐싱된 웹 객체가 근원지 서버에서 변경될 수 있으므로 일관성유지가 필요하다. 하지만 앞서 말한 것처럼 웹캐시에서는 일관성의 불일치가 큰 문제를 야기하지 않는 경우가 대부분이다. 따라서 `적응적 TTL(adaptive Time to Live) `같이 약한 일관성 유지 기법을 사용한다.



`polling-every-time` 

- 캐시에 존재하는 객체의 요청이 있을 때마다 근원지 서버에 객체의 변경 여부를 확인
- 강한 일관성 유지라서, 지연시간 증가, 네트워크 유통량 증가, 웹서버 과부하를 야기



`invalidation` 

- 근원지 서버가 자신의 객체를 캐싱하고 있는 모든 프록시 서버를 기록해두었다마, 해당 객체가 변경된 경우 해당 프록시 서버들에 변경사실을 알려주는 방법
- 강한 일관성 유지라서, 지연시간 증가, 네트워크 유통량 증가, 웹서버 과부하를 야기



`adaptive TTL` 

- 캐시내의 객체에 대한 요청이 발생했을 때, 해당 객체의 **최종 변경 시각**, **최종 확인 시각** 을 고려하여 변경되었을 가능성이 높은 경우에만 근원지 서버에 변경 여부를 확인하는 방법.
- LMF(Last Modified Factor)가 임계값 이상인경우 변경 가능성이 높다고 판단.





## 4. 웹캐시의 공유 및 협력



`인터넷 캐시 프로토콜(Internet Cache Protocol: ICP)` : 동료 프록시캐시들 사이에서 웹 객체의 검색 및 전송을 지원하기 위한 프로토콜이다.

1. A 프록시 서버에 웹 객체 요구했는데, 요청한 객체를 캐싱하고 있지 않은 경우
2. 모든 동료 프록시 서버에 ICP 질의를 멀티캐스트로 함(ICP 질의는 HTTP에 비해 부담이 적음)
3. 동료중 하나(B)가 객체를 가지고 있다고 답신을 보냄
4. A->B로 HTTP요청을 보내 객체를 받아와서 사용자에게 전달



`캐시 배열 간 경로지정 프로토콜(Cache Array Routing Protocol: CARP)`

- 공유 웹 캐시들에 동일한 웹 객체들이 중복저장되는 것을 막기 위해 URL 공간을 분할하여 자신에게 배정되는 객체만 저장



`디렉토리 기반 프로토콜(directoty basd protocol)`

- 공유된 웹 캐시에 저장된 객체들의 위치 정보를 디렉토리에 유지하여 ICP 프로토콜의 멀티캐스트 부담을 없앰





## 5. 웹 캐시의 사전인출 기법



`사전 인출 기법`

- 아직 요청되지 않은 객체를 미리 받아옴으로서, 응답 지연시간을 줄이기 위한 방법
- `예측 사전 인출 기법`과 `대회식 사전인출 기법`이 있다.



`예측 사전인출 기법`

- 웹 페이지간의 관계 그래프를 구성하여, 하나의 웹 페이지가 참조되었을때 새로운 웹페이지가 참조될 확률을 과거의 참조 기록으로 예측



`대화식 사전인출 기법`

- 사용자가 HTML 문서에 대해 요청하면, 이 HTML문에서 포함되거나, 연결된 웹 객체를 미리 받아오는 방법



`유효성의 사전확인 기법`

- 캐싱된 객체의 유효성을 미리 확인해 두었다가, 사용자가 해당 객체의 요청시 웹서버에 변경 여부를 확인하지 않고 곧바로 보내주는 방법





## 6. 동적 웹 객체의 캐싱 기법

앞서 설명한 캐싱은 정적 컨텐츠에 대한 캐싱이었다면, 아래에서 설명하는 부분은 ASP, CGI등 동적 웹 컨텐츠를 처리하는 부분을 설명한다.

동적 웹 컨텐츠는 실시간성을 요구하여, 이를 처리하는데 상당한 시간이 걸려 부하를 야기한다. 또한 사용자의 요청에 대하 프로그램 실행 후 그 결과를 보내주어야 해서 동일한 URL에 대해서 서로 다른 결과가 필요하다.

따라서 현재까지의 동적 웹 컨텐츠 캐싱을 주로 웹서버 내부에서 빠른 처리를 위해 프론트엔드에 설치하는 `역방향 프록시 캐시` 또는 `웹서버 가속기` 중 일부에서 활용되고 있는 실정이다.

하지만, 현재에는 캐싱 가능한 부분을 부분적으로 표시하는 태그등을 활용하고 있고, 일반적인 웹 캐시에서도 이와 같은 방법을 사용할수 있을 것으로 기대된다.













