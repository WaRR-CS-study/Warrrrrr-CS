# Ch6. CPU 스케줄링



## :question:질문

1. I/O 바운드 프로세스와 CPU 바운드 프로세스 중 CPU버스트가 길게 나타나는 프로세스와 그 이유는?
   - CPU 바운드 프로세스 /  I/O 작업을 거의 수행하지 않기 때문에 인터럽트에 걸리지 않고 CPU 계산만을 지속적으로 수행한다. 따라서  CPU버스트가 길다. 



2. CPU 스케줄링이 필요한 이유?
   - CPU를 사용하는 패턴이 상이한 프로그램들이 함께 실행되기 때문이다.
   - 프로세스의 CPU버스트가 제각기 다르기 때문에 처리 순서에 따라서 응답시간, 대기시간 등이 달라지기 때문이다.



3. CPU 스케줄링의 비선점형 방식과 선점형 방식의 차이점?
   - 선점형 방식은 스케줄러가 프로세스의 CPU를 강제로 뺏어올 수 있는 방식이고, 비선점형 방식은 스케줄러가 프로세스의 CPU를 강제로 뺏어올 수 없는 방식이다.



4. 선입선출 스케줄링에서 콘보이 현상이란?
   - CPU버스트가 긴 프로세스가 앞에 있을 경우 짧은 프로세스들이 기다리는 시간이 길어지면서 평균 대기시간이 늘어나는 현상이다.



5. SJF(최단 작업 우선 스케줄링)에서 나타나는 기아현상을 설명하시오.
   - CPU 버스트가 짧은 프로세스가 계속해서 들어와서 CPU 버스트가 긴 프로세스가 계속해서 CPU를 점유하지 못하는 현상이다.



6. SJF 스케줄링에서 기아현상을 극복할 수 있는 방법이 무엇인가?
   - 대기시간이 길어지면 우선순위를 높이는 노화기법이 있다.



7. 멀티레벨 큐의 전위 큐와 후위 큐에서는 각각 어떤 방식의 스케줄링 방법을 사용하는가?
   - 전위큐는 대화형 프로세스를 많이 처리하기 때문에 라운드 로빈을 사용하고, 후위큐는 계산 위주의 프로세스를 처리하기 때문에 선입선출 스케줄링을 사용한다.



8. CPU 버스트 시간에 비례해서 프로세스의 대기시간이 늘어나는 스케줄링 방식은 무엇인가?
   - 라운드 로빈 스케줄링
   - 각 프로세스가 CPU를 연속적으로 사용할 수 있는 시간이 제한되기 때문에 CPU 버스트가 긴 프로세스는 다 완료하지 못하고 뒤로 밀려나고, CPU 버스트가 짧은 프로세스는 그만큼 먼저 완료되기 때문이다.





---





**CPU 기계어 명령의 종류**

1. CPU 내에서 수행되는 명령

   - Add

2. 메모리 접근을 필요로 하는 명령

   - Load, Store

3. 입출력을 동반하는 명령

   - 키보드 입력, 화면 출력, 디스크에 파일 형태로 저장 등




:bulb: 프로그램이 수행되는 과정은 비교적 빠른 CPU 버스트와 느린 I/O 버스트의 조합으로 이루어진다.

- I/O 바운드 프로세스
  - I/O 요청이 빈번해 CPU 버스트가 짧게 나타나는 프로세스
  - 주로 사용자 인터렉션을 계속 받는 대화형 프로그램이 해당
- CPU 바운드 프로세스
  - I/O 작업을 거의 수행하지 않아 CPU 버스트가 길게 나타나는 프로세스
  - 계산 위주의 프로그램이 해당



:exclamation: **CPU 스케줄링이 필요한 이유**

- CPU를 사용하는 패턴이 상이한 프로그램들이 함께 실행되기 때문이다.
- 프로세스의 CPU버스트가 제각기 다르기 때문에 처리 순서에 따라서 응답시간, 대기시간 등이 달라지기 때문이다.



 컴퓨터 프로세스의 대부분은 I/O 바운드 프로세스들이다. 따라서 I/O 바운드 프로세스들이 우선적으로 CPU를 사용할 수 있도록 하는 스케줄링이 필요하다.



## 1. CPU 스케줄러

- CPU 스케줄러

  - 준비 상태에 있는 프로세스들 중 어떠한 프로세스에게 CPU를 할당할 지 결정하는 운영체제의 코드

- CPU 스케줄링이 필요한 대표적인 경우들

  1. 실행 상태에 있던 프로세스가 I/O 요청에 의해 봉쇄 상태로 바뀌는 경우

  2. 실행 상태에 있던 프로세스가 타이머 인터럽트 발생에 의해 준비 상태로 바뀌는 경우

  3. I/O 요청으로 봉쇄 상태에 있던 프로세스가 다시 준비 상태로 바뀌는 경우

  4. CPU에서 실행 상태에 있는 프로세스가 종료되는 경우

- CPU 스케줄링 방식

  - 비선점형
    - 프로세스가 스스로 CPU 반납하기 전까지 CPU를 빼앗기지 않는 방법
    - 1번, 4번 경우
  - 선점형
    - 프로세스로부터 CPU를 강제로 빼앗을 수 있는 스케줄링 방법
    - 2번, 3번  경우



## 2. 디스패처

- 디스패처
  - CPU 스케줄러에 의해 선택된 프로세스가 CPU를 할당받고 작업을 수행할 수 있도록 환경설정을 하는 운영체제의 코드
  - 현재 수행중이던 프로세스의 문맥을 PCB에 저장하고, 새로 선택된 프로세스의 문맥을 PCB로부터 복원한 후 CPU를 넘기는 과정을 수행한다.
  - 디스패치 지연시간(dispatch latency)
    - 디스패처가 하나의 프로세스를 정지시키고 다른 프로세스에게 CPU를 전달하는 데 걸리는 시간
    - 대부분이 문맥교환 오버헤드에 해당된다.



## 3. 스케줄링의 성능 평가

- 시스템 관점
  - CPU 이용률, CPU 처리량
- 사용자 관점
  - 소요시간, 대기시간, 응답시간

**용어**

- CPU 이용률 : CPU가 일을 한 시간 / 전체 시간

- CPU 처리량 : CPU 버스트를 완료한 프로세스의 개수
- 소요시간 : 프로세스가 CPU를 요청한 시점부터 CPU 버스트가 끝날 때까지 걸린 시간, 즉 준비큐에서 기다린 시간 + 실제로 CPU를 사용한 시간
- 대기시간 : CPU 버스트 기간 중 준비 큐에서 기다린 시간
- 응답시간 : 준비 큐에 들어온 후 첫 번째 CPU를 획득하기까지 기다린 시간



## 4. 스케줄링 알고리즘



1. 선입선출 스케줄링(First-Come First-Served)

   - 프로세스가 준비 큐에 도착한 시간 순서대로 CPU를 할당하는 방식
   - 콘보이 현상
     - CPU버스트가 긴 프로세스가 앞에 있을 경우 짧은 프로세스들이 기다려야하는 상황이 발생할 수 있다.

   

2. 최단작업 우선 스케줄링(Shortest-Job First)

   - CPU 버스트가 가장 짧은 프로세스에게 먼저 CPU를 할당하는 방식
   - 평균 대기시간을 가장 짧게 하는 최적 알고리즘
   - 비선점형 : CPU 버스트가 더짧은 프로세스가 도착해도 스케줄링 하지 않는다.
   - 선점형 : CPU 버스트가 더 짧은 프로세스가 도착하면 해당 프로세스에게 CPU를 할당한다.
   - 기아 현상
     - CPU 버스트가 짧은 프로세스가 계속 도착할 경우 CPU버스트가 긴 프로세스는 영원히 CPU를 할당받지 못하는 현상

   

3. 우선순위 스케줄링

   - 준비 큐에서 기다리는 프로세스들 중 우선순위가 가장 높은 프로세스에게 제일 먼저 CPU를 할당하는 방식
   - 우선순위를 결정하는 방식은 여러가지가 있을 수 있다.
     - CPU 버스트시간(SJF), 시스템 관련 중요도 등
   - SJF와 마찬가지로 비선점형과 선점형 방식으로 구현할 수 있으며, 선점형에서 기아 현상이 발생할 수 있다.
   - 노화 기법 : 대기시간이 길어지면 우선순위를 조금씩 높여 기아 현상을 해소하는 방법

   

4. **라운드 로빈 스케줄링**

   - 시분할 시스템의 성질을 활용한 스케줄링 방식
   - 각 프로세스가 CPU를 연속적으로 사용할 수 있는 시간이 제한되며, 제한된 시간을 **할당 시간**이라고 한다.
   - 시간이 경과하면 CPU를 회수해 다른 프로세스에게 CPU를 할당한다.
   - 따라서 CPU 버스트 시간에 비례해서 프로세스의 대기시간이 늘어나는 공정한 스케줄링 방식이라고 할 수 있다.
   - 할당시간이 너무 길면 FCFS와 같아지고, 너무 짧으면 문맥교환 오버헤드가 너무 커진다.
   - 여러 종류의 이질적인 프로세스가 같이 실행되는 환경에서 효과적이다.
   - SJF 방식보다 평균 대기시간을 길지만 응답시간은 더 짧다.
   - 자세한 예시는 p163-168 참고



5. 멀티레벨 큐
   - 준비 큐를 여러 개로 분할해 관리하는 스케줄링 기법
   - 여러 큐를 운용하기 때문에 어떤 큐를 우선적으로 스케줄링 할 지와 프로세스를 어느 큐에 넣어야 할 지 결정하는 메커니즘이 필요하다.
   - 일반적으로 대화형 작업을 위한 전위 큐와 계산 위주의 작업을 위한 후위 큐로 분할함
   - 전위 큐에서는 응답시간을 짧게 하기 위해 라운드 로빈 사용
   - 후위 큐에서는 계산 위주의 작업을 위해 선입선출 스케줄링 사용



6. 멀티레벨 피드백 큐
   - 멀티레벨 큐에서 준비 큐간에 이동이 가능해진 스케줄링 기법
   - 노화 기법을 멀티레벨 피드백 큐에서 구현이 가능하다.
   - 상위에 있는 큐일 수록 우선순위가 높으며, CPU 버스트가 짧은 프로세스를 우선적으로 처리하기 위해 상위 큐는 라운드 로빈을 이용한다.

![image-20210630192805811](chapter6.assets/image-20210630192805811.png)



7. 다중처리기 스케줄링

   - CPU가 여러 개인 환경에서의 스케줄링
   - 일부 CPU에 작업이 편중되는 현상을 방지하기 위해 부하균형 매커니즘을 필요로 함

   - 대칭형 다중처리 : 각 CPU가 독립적으로 스케줄링을 결정
   - 비대칭형 다중처리 : 하나의 CPU가 다른 모든 CPU의 스케줄링을 책임지는 방식

   

8. 실시간 스케줄링

   - 각 작업마다 주어진 데드라인이 있는 시스템에서의 스케줄링
   - 경성 실시간 시스템 : 데드라인을 무조건 지켜야 하는 시스템 ex) 미사일 발사
   - 연성 실시간 시스템 : 데드라인을 지키지 못했다고 위험한 상황이 발생하지는 않는 시스템 ex) 멀티미디어 스트리밍 시스템

   - EDF 스케줄링 : 데드라인이 얼마 남지 않은 요청을 먼저 처리하는 방식



## 5. 스케줄링 알고리즘의 평가

1. 큐잉모델 : 수학적 계산
2. 시뮬레이션 : 가상 스케줄링 프로그램
3. 구현 및 실측 : 실제로 하기