# Chapter 7. 메모리 관리



# 💗 문제



## 1. 주소 바인딩의 세가지 방식이 뭔가요 ?



## 2. 페이징 기법에 대해 설명해주세요.



## 3. 세그멘테이션이 무엇인가요 ?



# 💗 요약



이번 Chapter에서는 이 주소와 메모리를 어떻게 바인딩하는지에 대해 공부하는 챕터이다.



## 1. 주소 바인딩



 주소 바인딩이란 프로세스의 논리적 주소를 물리적 주소로 연결시켜주는 작업이다.

 프로그램이 실행을 위해 메모리에 적재되면 그 프로세스를 위한 독자적인 주소 공간이 생성되며 이를 논리적 주소 혹은 가상 주소라고 부른다. 가상 주소는 그 프로세스에서 실행 순서를 나타내기 때문에 0번지부터 순서대로 지정되기 때문에 실제 물리적 데이터 베이스 위치와는 다르다. 그렇기 때문에 이 **가상 주소와 실제 물리적으로 DB에 저장된 위치를 매핑할 필요가 있는데 이를 주소 바인딩이라고 한다.**

※ 물리적 메모리의 낮은 주소 영역에는 운영체제가 올라가고 높은 주소 영역에는 사용자 프로세스들이 올라간다.



### - 주소 바인딩 방식

주소 바인딩 방식은 프로그램이 적재되는 물리적 메모리 주소가 결정되는 시기에 따라 분류된다.



1. 컴파일 타임 바인딩

   물리적 메모리 주소가 프로그램을 컴파일할 때 결정되는 방식

   

2. 로드 타임 바인딩

   프로그램이 실행되기 시작할 때 물리적 메모리 주소가 결정되는 방식

   

3. 실행 시간 바인딩

   프로그램이 실행을 시작한 후에도 그 프로그램이 위치한 물리적 메모리상의 주소가 변경될 수 있는 방식
   
   이 방식은 CPU가 주소를 참조할 때 마다 물리적 위치를 파악하기 위해 MMU를 사용해야하는 특징이 있다.



#### 	※ MMU 기법

​		 **MMU는 하드웨어 장치로 논리적 주소와 물리적 주소로 매핑해주는 장치이다.** CPU가 특정 프로세스의 논리적 주소를 참조하려고 할 때 MMU 기법은 그 주소		값에 기준 레지스터의 값을 더해 물리적 주소값을 얻어낸다. 이때 기준 레지스터는 재배치 레지스터라고도 부르며 그 프로세스의 물리적 메모리 시작 주소를 		갖고 있다.

​		  하지만 다중 프로그래밍 환경에서 물리적 메모리 안에 여러 개의 프로세스가 동시에 올라가 있어 논리적 주소값과 재배치 레지스터 값을 더하면 해당 프로세		스의 주소공간을 벗어나는 경우가 발생할 수 있다. 이렇게 되면 메모리 보안이 깨질 우려가 있어 주소공간이 벗어나는지를 파악하기 위한 한계 레지스터를 사		용한다.



## 2. 메모리 관리와 관련된 용어



### 1) 동적로딩



​	 여러 프로그램이 동시에 메모리에 올라가서 수행되는 다중 프로그래밍 환경에서 메모리 사용의 효율을 높이기 위해 사용하는 기법 중 하나, 프로세스의 주소 공         	간 전체를 메모리에 다 올리는 것이 아니라 해당하는 부분이 불렸을 때 그 부분만을 메모리에 적재하는 방식을 의미한다. 



### 2) 동적 연결



​     연결이란 프로그래머가 작성한 소스 코드를 컴파일하여 생성된 목적 파일(Object File)과 이미 컴파일된 라이브러리 파일(Library File)을 묶어 하나의 실행파일	을 생성하는 과정이다. 이 개념은 C나 JAVA에서는 코드 작성자가 직접 만들기도 하지만 Python에서는 따로 할 필요가 없어서 부연 설명하자면 java에서는 소스	코드를 javac 명령어로 class 파일로 만드는데 이러한 class들이 여러개가 있어서 이것을 여러 개를 묶어서 사용하는 것을 의미한다.

​	 동적 연결이란 컴파일을 통해 생성된 목적 파일과 라이브러리 파일 사이의 연결을 프로그램의 실행 시점까지 지연시키는 기법. 여러 개의 Object 파일을 한번에    	묶어서 Libarary File와 통채로 합쳐 버리는 것을 정적 연결이라고 하는데 이는 낭비가 될 수 있기 때문에 각 Object 파일이 실행될 때마다 라이브러리와 연결하는 	기법이다.



### 3) 중첩



​	  프로세스의 주소 공간을 분할해 실제 필요한 부분만을 메모리에 적재하는 기법을 말한다. 이는 동적 로딩과 유사하지만 중첩과 동적로딩은 그 이유가 다르며 중	첩은 운영체제의 지원 없이 프로그래머에 의해 구현되어야 했던 옛날 기법이다. 중첩이 메모리가 부족해서 사용되는 것이였다면 동적로딩은 메모리 사용 효율을 	위한 것이라고 생각하면 될 것 같다.



### 4) 스와핑



​	  메모리에 올라온 프로세스의 주소 공간 전체를 어떠한 이유 때문에 디스크의 스왑 영역에 일시적으로 내려놓는 것을 말한다. 이때 스왑 영역은 백킹스토어라고	도 부르며, 작업 방향에 따라 스왑 인, 스왑 아웃이라고도 불린다.



## 3. 물리적 메모리의 할당 방식



### 1) 연속 할당 방식



 프로세스를 메모리에 올릴 때 그 주소 공간을 여러 개로 분할하지 않고 물리적 메모리의 한 곳에 연속적으로 적재하는 방식이다.



1. 고정 분할 방식

   물리적 메모리를 주어진 개수만큼의 영구적인 분할로 미리 나누어두고 각 분할에 하나의 프로세스를 적재해 실행시킬 수 있도록 한다.

   

2. 가변 분할 방식

   고정분할 방식과 달리 메모리에 적재되는 프로그램의 크기에 따라 분할의 크기, 개수가 동적으로 변하는 방식,

   ※ 동적 메모리 할당 문제

   메모리의 어떤 위치에 올릴 것인지 결정하는 문제로 가용 공간을 찾아 프로세스를 올리는 것이다.

   - 최초적합 방법 - 가장 먼저 찾아지는 곳에 할당
   
   - 최적적합 방법 - 올라갈 수 있는 크기 중 가장 작은 크기

   - 최악적합방법 - 가장 크기가 큰 곳에 할당
   
     

### 2) 불연속 할당 방식



 하나의 프로세스가 물리적 메모리의 여러 위치에 분산되어 올라갈 수 있는 메모리 할당 기법이다.

**세그멘테이션 기법, 페이지드 세그멘테이션 기법 등**이 있다.



## 4. 페이징 기법



 프로세스의 주소 공간을 동일한 크기의 페이지 단위로 나누어 물리적 메모리의 서로 다른 위치에 **페이지**들을 저장하는 방식이다.

 페이징 기법에서는 물리적 메모리와 동일한 크기의 **프레임**으로 미리 나누어둔다. 이 때문에 동적 메모리 할당 문제가 발생하지 않는다.



### 1) 주소 변환 기법



페이징 기법에서는 CPU가 사용하는 논리적 주소를 페이지 번호와 페이지 오프셋으로 나누어 주소변환에 사용한다. 

특정 프로세스의 p번째 페이지가 위치한 물리적 메모리의 시작 위치는 프로세스의 페이지 테이블에서 p번째 항목을 찾아보는 방식이다.

페이지 오프셋은 페이지 내에서의 변위(displacement)를 알려준다. 즉 기존 주소값 p에 변위인 d를 더해 물리적 주소를 얻는 것이다.



### 2) 페이지 테이블의 구현



페이징 기법에서는 보통 페이지 테이블이 활용된다. 

페이지 테이블은 앞서 주소 변환 기법에서 활용되는 것과 같은 방식인데 이럴 경우 페이지 테이블에서 한 번, 그리고 이를 통해 얻어낸 물리적 주소로 디스크에 접근하는 것이 한 번으로 총 두번의 메모리 접근이 일어난다. 이 때 TLB(Translation Look-aside Buffer)를 사용하여 바로 접근하는 방법도 함께 활용된다. 

이 TLB로 사용되는 하드웨어는 가격이 비싸기 때문에 빈번히 참조되는 페이지에 대한 주소 변환만을 담게 된다. 이 TLB의 구현에는 병렬 탐색(모든 항목을 동시에 탐색할 수 있는 기능)이 가능한 연관 레지스터를 사용한다.



### 3) 계층적 페이징



 현대의 컴퓨터는 주소 공간이 매우 큰 프로그램을 지원하기 때문에 계층적 페이징 기법을 지원한다. 이 기법은 앞서 비유한 바 대로 주소지를 나눈다고 생각하면 편하다. 즉 대전시 유성구 덕명동처럼 계층을 나누어 차례대로 접근하는 방식이다. 현재는 주로 2단계 페이징 기법을 사용하는데 이 때 먼저 접근하는 것을 외부 페이지 테이블이라고 하며 다음에 접근하는 것을 내부 페이지 테이블이라고 한다.



### 4) 역페이지 테이블



페이지 테이블 방식이 낭비가 심한 이유는 기본적으로 프로세스의 모든 페이지에 대한 페이지 테이블 항목을 다 구성해야 하기 때문이다. 

역페이지 테이블은 이 비효율을 해결하기 위한 기법으로 사용될 수 있다. 

역페이지 테이블 기법은 물리적 메모리의 페이지 프레임 하나당 페이지 테이블에 하나씩의 항목을 두는 방식이다. 

즉 기존의 페이지 테이블 기법인 논리적 메모리의 페이지 테이블이 아닌 물리적 메모리의 페이지 테이블을 만드는 것을 말한다. 

이 방식은 비효율적일 수 있기 때문에 일반적으로 병렬 탐색이 가능한 연관 레지스터에 보관해 사용한다.



### 5) 공유 페이지



 공유 코드는 메모리 공간의 효율적인 사용을 위해 여러 프로세스에 의해 공통으로 사용될 수 있도록 작성된 코드를 말한다. 공유코드는 읽기 전용 특성을 갖고 있으며 재진입 가능 코드 또는 순수 코드라고도 불린다.

 이에 대비되는 개념으로 사유 페이지가 있는데, 이것은 공유하지 않고 프로세스별로 독자적으로 사용하는 페이지를 말한다.



### 6) 메모리 보호



 페이지 테이블의 각 항목에는 주소 변화 정보뿐 아니라 메모리 보호를 위한 보호비트와 유효-무효 비트를 두고 있다.

 **보호 비트**는 각 페이지에 대한 접근 권한의 내용을 담고 있다.

 **유효-무효 비트**는 해당 페이지의 내용이 유효한지에 대한 내용을 담고 있다.

 (그러니까 인덱스 아웃 오브 레인지를 방지하기 위한 기법이라고 생각하면 편하다.) 



## 5. 세그먼테이션



 앞서 살펴본 페이지 기법이 프로세스를 동일한 크기 단위의 페이지로 나누었다면 세그멘테이션 기법은 의미 단위인 세그먼트로 나누어 올리는 방식을 말한다. 

 세그멘테이션 기법은 세그멘트의 크기에 대한 정보와 세그멘트의 시작점에 대한 정보를 가진 두개의 테이블이 있으며 세그먼트 테이블 기준 레지스터(Segment Table Base Register)와 세그먼트 테이블 길이 레지스터(Segment Table Length Register)를 사용하여 접근한다. 

 이때 세그먼트의 길이 + 논리적 주소를 더했을 때 해당 프로세스에 할당된 limit 기준을 넘어가게 되면 Trap이 발동되어 멈추며 limit이 넘지 않을 경우 아닐 경우 해당 위치를 찾게 된다. (210p 참조)

 세그먼테이션 기법은 앞서 페이징 기법에서 사용된 메모리 보호 기능과 공유 페이지 기능이 모두 구현되어 있다.

 세그멘테이션 기법은 기능 단위로 나뉘어져 있어서 페이징 기법보다 공유와 보안 측면이 훨씬 효과적이다. 즉 접근 권한의 설정이 용이한 것이다.  



## 6. 페이지드 세그먼테이션



 페이지드 세그멘테이션 기법은 페이징 기법과 세그먼테이션 기법의 결합으로 각 세그먼트의 크기를 페이징의 정수배로 고정하여 페이징 기법처럼도 활용할 수 있는 기법이다. 페이지드 세그멘테이션의 주소 변환을 위해서는 외부의 세그멘트 테이블과 내부의 페이지 테이블이 있는데 이를 사용하는 것은 앞서 살펴본 2단계 페이지 테이블 기법과 유사한 구조이다.

 즉 세그멘트 테이블을 통해 내부의 페이지 테이블로 접근하여 그 세그멘트가 어떤 페이지에 있는지를 알아내고 이 페이지 테이블을 활용하여 물리적 주소를 얻어내는 방식이다.



