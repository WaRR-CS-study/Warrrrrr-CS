# 📙 chap7. 메모리 관리

이 장에서는 시간적, 공간적 효율성을 높이기 위한 메모리 관리 방법을 기술한다. 주요 내용으로는 메모리(RAM) 상에 저장되는 논리 메모리 주소와, 실제 프로세스가 저장되어 있는 물리주소(c or d)를 맵핑하는 방법이 있다.



[TOC]



## 1. 주소 바인딩

### 1.1 논리적 주소 vs 물리적 주소

- 논리적 주소
  - 프로그램이 실행되었을때 메모리에 적재된 주소 공간의 주소
  - 프로세스마다 독립적으로 할당되며 0번 부터 시작(인덱스 개념)
- 물리적 주소
  - 실제 저장된 물리적 주소
  - 낮은 주소(작은 숫자의 인덱스) 에는 운영체제가 올라가고, 높은 주소에는 사용자 프로세스가 있다.



### 1.2 주소 바인딩

#### 정의

논리적 주소를 물리적 주소로 연결시키는 작업이다.



#### 분류

##### 컴파일 타임 바인딩 

- 프로그램을 컴파일할때 결정되는 주소 바인딩
- 절대 주소를 생성하게 되어서 `절대 코드 바인딩` 이라고도 한다.
- 물리적 메모리 위치를 변경하려면 컴파일을 다시 해야함
- 비현실적이고 현대의 시분할 컴퓨팅 환경에서 사용하지 않음



##### 로드 타임 바인딩

- 프로그램이 실행될 때 물리적 메모리가 결정되는 방식
- 로더(사용자 프로그램을 메모리에 적재시키는 프로그램)가 물리적 메모리의 위치를 고정 시키는 역할을 한다.
- 컴파일러가 재배치 가능 코드를 생성한 경우에 가능하다.



##### 실행시간 바인딩

- 프로그램 실행 후에도 물리적 메모리가 변경될 수 있는 바인딩
- 주소 매핑 테이블을 이용하여 바인딩을 점검한다.
- 기준 레지스터, 한계 레지스터, `MMU`등 하드웨어적 장치 필요





### 1.3 MMU 기법

#### 정의

논리적 주소를 물리적 주소로 맵핑해주는 하드웨어 장치



#### 원리

- 논리적 주소에 기준 레지스터(재배치 레지스터 라고도 함) 값을 더해 물리적 주소를 얻어낸다.
- 기준 레지스터는 프로세스의 물리 메모리 시작 주소를 가지고 있다.
- MMU에서는 프로그램이 물리적 메모리의 한장소에 연속적으로 저장된다 가정하므로, 시작 주소만 알면 주소를 쉽게 변환할 수 있다.
- 오프셋 : 기준 레지스터에 저장되어 있는 값으로, 논리적~물리적 메모리가 얼마나 떨어져있는가를 나타냄

- 프로세스는 각자의 독립된 논리주소를 가지기 때문에, 동일한 논리주소라도 프로세스가 다르면 서로 다른 물리 주소를 가르킨다. 따라서 MMU는 `문맥교환`으로 수행중인 프로세스가 바뀔때마다 재배치 레지스터의 값을 그에 맞춰 바꾼다.



#### 보안

- 메모리 안에서는 여러 프로세스가 같이 놓여져있는데, 논리주소에 재배치 레지스터 값을 더하다가 해당 프로세스의 주소 공간을 벗어나는 경우가 있다. (아웃 오브 레인지 같은,,)
- 이렇게 되면 다른 프로세스의 메모리영역을 침범하여 `메모리 보안`이 이루어지지 않고, 위험하다.
- `한계 레지스터` : 주소 공간을 넘는지 안넘는지 체크하는 용도로, 논리주소의 최대값(프로세스의 크기)을 담는다.



#### 메모리 보안을 달성하는 법

논리주소 값이 한계 레지스터 내에 저장된 프로세스 크기 보다 작은지 확인

- 큰 경우 : 다른 프로세스의 메모리 영역에 접근하는 행위로 간주하여 트랩을 발생 -> 강종
- 작은 경우 : 재배치 레지스터 값을 더해 물리적 주소를 구하여 접근한다.





## 2. 메모리 관리와 관련된 용어

동적 로딩, 동적 연결, 중첩, 스와핑 등이 있다.



### 2.1 동적 로딩

- 다중 프로그래밍 환경에서 메모리 효율을 높이기 위한 방법 중 하나
- 프로세스의 특정 부분이 불릴 때 그 부분만 메모리에 적재하는 방식
- 오류처리 루틴 같은 자주 사용하지 않지만, 메모리를 잡아먹는 방어용 코드를 메모리에 올리지 않아 효율적으로 메모리를 관리한다.
- 운영체제의 특별한 지원 없이 프로그램 자체에서 구현 가능



### 2.2 동적 연결

- 목적파일(소스코드 컴파일)과 라이브러리 파일(이미 컴파일된 파일) 사이의 연결을 프로그램의 실행까지 지연지시키는 방법
- 정적 연결(목적 파일과 라이브러리 파일을 합쳐 놓은 것)은 실행 파일의 크기가 크고, 각 프로세스별로 라이브러리를 각각 적재해서 메모리 낭비가 심한데 이와 반대 개념이다.
- 프로그램이 실행되면서 라이브러리 함수를 호출할때 불러오는 방식
- 스텁 : 실행 파일의 라이브러리 호출 부분에 해당 라이브러리의 위치를 찾기 위한 작은 코드
- 스텁을 통해 메모리에 이미 존재한다면 바로 가져오고, 아니면 메모리 적재 후 가져온다.
- 다수의 프로그램에서 공통으로 사용한 경우 한번 불러온것으로 공통으로 사용할 수 있어서 효율적
- 운영체제의 자원을 필요로 한다.



### 2.3 중첩

- 프로세스의 주소공간을 분할하여 실제 필요한 부분만 메모리에 적재
- 과거에 메모리 크기의 제약으로 하나의 프로세스 조차 다 못올리는 경우에 당장 필요한 부분만 메모리에 올리고, 그 부분이 끝나야 나머지 부분을 올리는 방식이라 동적로딩과는 다르다.
- 즉, 동적 로딩은 더 많은 프로세스를 동시에 올려놓고 쓰기 위한 이용률 향상 목적이고, 중첩은 메모리 용량보다 큰 프로세스를 실행하기 위한 어쩔수 없는 선택이었다.
- 운영체제 지원 없이 프로그래머가 구현했으며, 상당히 복잡하다.



### 2.4 스와핑

- 메모리에 올라온 프로세스의 주소 공간 전체를 디스크의 스왑영역(백킹스토어)에 일시적으로 내려놓는것.
- 프로세스 수행 중 일시적으로 저장하는 짧은 저장공간
- 스와핑의 목적은 **메모리에 존재하는 프로세스의 수를 조절하는 것이다**
- 너무 많은 프로그램에 메모리에 올라가면 메모리가 잘게잘게 쪼개져서 성능이 떨어지기 때문





## 3. 물리적 메모리의 할당 방식

사용자 프로세스 영역 관리 방법은 프로세스를 메모리에 올리는 방식에 따라 연속할당, 불연속 할당으로 나뉜다.



### 3.1 연속 할당

프로세스를 메모리에 올릴때 물리적 메모리의 한 곳에 연속적으로 적재하는 방식으로 `고정분할 방식`과 `가변분할 방식` 으로 나뉜다.



#### 고정분할 방식

- 물리적 메모리를 주어진 개수만큼, 동일한 크기로 영구적으로 분할
- 따라서 동시에 메모리에 올릴 수 있는 프로그램 수가 고정되며, 가변분할에 비해 융통성이 떨어진다.
- 외부조각과 내부조각이 둘다 발생할 수 있으며, 그나마 외부조각은 작은 프로세스에게 할당하면 되지만, 내부조각을 해결할 방법이 없어서 메모리 낭비가 될수밖에 없다.



#### 가변분할 방식

- 프로그램의 크기에 따라 분할의 크기, 개수가 동적으로 변하는 방식
- 내부조각은 발생할 일이 없지만, 실행되던 작은 프로그램이 종료되면 이를 담고 있던 메모리가 비어 외부조각이 생길 수 있음
  - 컴팩션(사용중인 메모리, 가용공간을 좌우로 분리하여 큰 덩어리를 만드는 것)으로 외부조각이 생기는 것을 막을 수 있다.
  - 하지만 메모리상 위치를 상당 부분 이동 시켜 비용이 많이 든다. (파이썬 pop느낌)
  - 따라서 적은 수의 메모리 이동으로 효율적인 컴팩션을 해야하지만 복잡하다.
  - 메모리 주소를 옮기는거라 실시간 바인딩에서만 가능하다.



#### 동적 메모리 할당 문제

- 가변 분할 방식에서, 물리적 메모리 내 가용 공간중 어떤 위치에 올릴 것인지 결정하는 문제.
- 가용공간 : 사용되지 않은 메모리 공간, 여러곳에 산발적으로 존재 가능
- 연속 할당에서는 프로세스의 주소 공간 전체를 담을 가용공간이 필요한데, 이러한 가용공간에 여러 곳에 흩어져있다.
- 그래서 운영체제는 이를 효율적으로 관리하기 위해 메모리공간과, 가용공간에 대한 정보를 각각 유지하고있다.



#### 동적 메모리 할당 문제 해결

- 최초 적합 : 프로그램 크기보다 큰 가용공간이 나오면 그 공간에 바로 프로그램을 올린다. 시간 효율적 / 공간은 그닥
- 최적 적합: 프로그램 크기보다 큰 것중 가장 작은 가용공간을 찾음. 시간 비효율 / 공간 효율
- 최악 적합 : 가용공간 중 가장 큰곳에 우선 할당. 둘다 비효율





### 3.2 불연속 할당

- 하나의 프로세스가 물리적 메모리의 여러 위치에 분산되어 올라갈 수 있는 기법
- 프로그램을 분할하는 기준에 따라 `페이징`, `세그먼테이션`, `페이지드 세그먼테이션`으로 나뉜다.





## 4. 페이징 기법

- 프로세스를 동일한 크기의 페이지 단위로 나누어 저장하는 방법
- 전체를 한번에 올릴 필요가 없이 일부는 백킹스토어에, 일부는 물리메모리에 두는 것이 가능
- 프레임 : 물리메모리를 페이지의 크기 로 나눠둔 것
- 페이지별로 나누어져서 동적 메모리 할당 문제가 발생하지 않는 장점이 있다.
- `페이지 테이블` : 특정 프로세스의 몇번째 페이지가 물리 메모리의 몇번째 프로그램에 들어있는지에 대한 변환 주소
- 외부조각은 발생하지 않지만, 프로그램크기가 항상 페이지의 배수가 되는건 아니라서 내부조각이 발생할 수 있음.



### 4.1 주소 변환 기법

- p(페이지 번호), d(페이지 오프셋)으로 논리 주소~ 물리 주소 변환에 사용
- p는 는 페이지 테이블의 인덱스로 사용, 해당 인덱스의 항목은 그 페이지의 물리 메모리의 기준 주소이다.
- 물리 주소 : pageTable[p] + d로 구할 수 있음. (테이블 이름이 pageTable는 아님, 이해를 돕기 위한 것)



### 4.2 페이지 테이블의 구현

- 주소 변환을 하기 위한 자료구조로, 물리 메모리에 위치함.
- `테이블 기준 레지스터`(메모리 내에서 페이지 테이블의 시작 위치)와 `페이지 테이블 길이 레지스터 `(페이지 테이블의 길이) 로 페이지 테이블에 접근한다.
- 페이징에서의 메모리 접근 연산
  - 주소 변환을 위해 페이지 테이블에 접근하는 것
  - 변환된 주소에서 실제 데이터에 접근하는 것
  - 위 2번이나 접근해야하는 오버헤드가 뒤따라서 `TLB`를 사용한다.



#### TLB(Translation Look-aside Buffer)

- 고속의 주소 변환용 하드웨어 캐시
- 가격이 비싸서 테이블의 모든 정보는 담지 못하고 자주 참조되는 페이지 정보만 담는다.
- 현재 요청하는 페이지가 TLB에 있으면 곧 바로 물리 메모리 프레임을 얻을 수 있다.
- 그렇지 않으면 페이지 테이블을 참조 하여야 하고, TLB의 기존 내용을 지우고 새로운 내용을 담는다.



#### 페이지 테이블과 TLB

- 페이지 테이블에는 하나의 프로세스에 대한 모든 페이지 정보가 들어있어서, 테이블의 시작위치에서 페이지 번호만큼 떨어진 항목에 접근하여, 프레임 번호를 얻는다.
- TLB는 전체가 아니라 일부만 저장된 캐시라서 (페이지번호, 프레임번호) 가 쌍으로 저장되어야 한다.
- 또한, TLB에 원하는 페이지 주소가 있는지 없는지 찾기 위해서는 TLB를 다 봐야하는 비효율이 있다.
- 그래서 TLB의 모든 항목을 동시에 탐색할수 있는 `병렬탐색`이 가능한 연관레지스터를 사용한다.



#### 연관 레지스터 사용시 평균 메모리 접근시간

EAT(Effective Access Time) : 평균 메모리 접근 시간 ; 시험에 잘 나오는 내용인듯?

메모리 접근 시간 : 1 , 연관 레지스터 접근시간 : ε, (ε -> 0) , α : 페이지 정보가 연관 레지스터에 존재할 확률

EAT = (1+ε)α + (2+ε)(1-α)

- (1+ε)α : 페이지 주소가 TLB에 있는 경우, TLB 접근 후 바로 메모리 접근
- (2+ε)(1-α) : 페이지 주소가 TLB에 없는 경우, TLB 접근 후 -> 페이지 테이블 접근 -> 메모리 접근



### 4.3 계층적 페이징

- 페이지 테이블을 사용하는 경우 페이지 테이블을 저장할 공간이 필요하다.
- 일반적으로 프로세스당 페이지 테이블로 4MB가 필요하다고하면, 램 4GB 중에서 페이지 테이블이 차지하는 공간이 많아져서 실제 사용하는 메모리 공간이 너무 적어진다.
- 이러한 낭비를 줄이기 위해 `2단계 페이징` 기법을 사용한다.



#### 2단계 페이징

- 외부 페이지 테이블, 내부 페이지 테이블 두단계의 걸친 페이지 테이블을 사용하는 방법
- 프로세스의 논리 주소를 두종류의 페이지 번호 (P1, P2)와 페이지 오프셋(d)로 구분.
  - P1, P2 : 외부, 내부 페이지 테이블 인덱스
  - <P1, P2, d> = P1+P2+d에 물리주소가 있다.
- 사용되지 않은 주소공간은 NULL로 설정하여 내부 페이지 테이블 생성을 하지 않는다. 내부 페이지가 있는 경우, 내부 페이지 테이블 자체를 하나의 프레임에 보관한다.
- **메모리 공간을 줄겠지만**, 주소 변환을 위해 거쳐야하는 페이지 테이블 수가 늘어나서 **시간적 손해**가 생긴다.
- 시간적 오버헤드를 줄이기 위해 `TLB`를 사용할수 있고, 이를 사용하면 **공간적 이득**과 **시간적 이득**을 동시에 얻을 수 있다.



### 4.4 역페이지 테이블

- 논리적 주소에 대해 페이지를 만드는 것이 아니라 물리적 주소에 대해 만드는 것으로, 프로세스마다 페이지 테이블을 두지 않고, 시스템 전체에 페이지 테이블을 하나만 두는 방법이다.
- 페이지 테이블은 pid(프로세스 번호)와 그 프로세스의 논리적 페이지 번호(p) 를 담고있게 된다.
- 주소 변환은 논리 -> 물리인 반면에 역페이지 테이블은 물리 -> 논리라서 주소 변환에 있어서는 다소 비효율적이다.
- 또한, 역페이지가 시스템 전체에 대한 페이지라서 규모가 큰데 탐색을 위해 전체를 다 찾아야한다는 시간적 비효율이 있다.
- 이를 해결하기 위해 앞서 언급한 연관 레지스터를 이용해 병렬 탐색을 하여 시간적 효율성을 꾀할 수 있다.



### 4.5 공유 페이지

- 공유 코드 : 메모리 공간의 효율을 위해 여러 프로그램에서 공통으로 사용될 수 있도록 작성한 코드
- 재진입 가능 코드 또는 순수 코드라고도 하며, **읽기 전용**이다.
- 공유 페이지는 공유 코드를 담고 있는 페이지로, 물리적 메모리에 하나만 적재되어도 여러 프로세스에서 사용하여 효율적이다.
- 다수 프로세스에서 접근할 수 있어야 해서, 모든 프로세스의 논리 주소 공간에 동일한 위치에 존재해야한다는 제약이 있다. 즉, 모든 프로세스에서 동일한 페이지 번호를 가져야한다.
- 사유 페이지 : 공유 페이지와 반대로 프로세스 내에서만 사용하는 부분, 논리 주소 어디에 있어도 무방



### 4.6 메모리 보호

- 페이지 테이블 각 항목에는 주소변환 뿐만 아니라 보호비트와, 유효-무효 비트를 두고 있다.
- 보호 비트 : 각 페이지에 대한 접근 권한 허용
- 유효- 무효 비트 : 해당 페이지 내용이 유효한지(그 페이지가 존재 하는지)





## 5. 세그먼테이션

- 하나의 프로세스를 구성하는 주소공간은 일반적으로 코드, 데이터, 스택인데 세그먼트는 주소 공간을 이러한 기능 단위, 의미단위로 나눈 것이다.
- 함수 하나하나도 각각 세그먼트로 정의 가능하며, 논리적 단위로 나눈 것이기에 크기가 균일하지 않다.
- 의미단위로 세그먼트를 나누기때문에, 크기가 다른 세그먼트를 메모리에 적재하는 부가적이 관리 오버헤드가 따른다.



### 5.1 주소 관리

- 논리 주소가 <세그먼트 번호, 오프셋>으로 나뉘어 사용된다
  - 세그먼트 번호 : 해당 프로세스 내 세그먼트 인덱스
  - 세그먼트 오프셋 : 그 세그먼트에서 얼마나 떨어져있는지



### 5.2 세그먼트 테이블

- 세크먼테이션에서는 페이징과 유사하게 `세그먼트 테이블`을 이용한다.
- 세그먼트 테이블은 `기준점`과 `한계점`을 가진다.
  - 기준점 : 그 세그먼트의 시작위치
  - 한계점 : 그 세그먼트의 길이 (세그먼트마다 길이가 다르기 때문에 저장해야 함)



### 5.3 세그먼트 레지스터

- 세그먼트 테이블 기준 레지스터(STBR)
  - 해당 프로세스의 세그먼트 테이블이 메모리의 어디에 있는지 그 시작 주소
- 세그먼트 테이블 길이 레지스터(STLR)
  - 그 프로세스의 세그먼트의 총 갯수



### 5.4 보안

- 세그멘테이션 기법에서는 논리 -> 물리 주소 변환 전에 두가지 사항을 확인한다.

  1. 요청된 세그먼트 번호가 STLR에 저장된 값보다 작아야한다. -> 아니면 예외 처리
  2. 논리 주소의 오프셋값이 그 세그먼트 길이보다 작아야 한다. -> 한계점, 오프셋 비교 -> 아니면 예외처리

  - 위 두 경우에 통과하지 않으면, 다른 프로세스의 메모리 영역에 접근 하는 것이므로 예외 처리한다.

- 세그먼트 테이블의 각 항목에 보호비트와 유효 비트를 둔다.

  - 보호비트 : 읽기, 쓰기, 실행 권한이 있는지
  - 유효비트 : 해당 세그먼트가 유효한지(현재 물리메모리에 적재되어 있는지)

- 공유 세그먼트 : 공유 페이지와 마찬가지로 모든 프로세서의 주소 공간에서 동일한 논리 주소에 위치해야 함

- 세그먼트는 의미단위로 나누어져서 페이징보다 공유와 보안 측면에서 효과적이므로, 의미있는 단위에서 수행하는 업무에서는 세그멘테이션이 장점을 가진다.



### 5.5 단점

- 세그먼트의 길이가 균일하지 않아 외부조각이 생긴다.
- 세그먼트를 어느 가용 공간에 할당할지에 대한 문제 발생
  - 최초적합 or 최적 적합 선택





## 6. 페이지드 세그멘테이션

- 위 두 기법의 장점만 취한것으로 의미단위의 세그먼트로 나누지만, 반드시 동일한 크기의 페이지 집합으로 구성한다.
- 물리적 메모리에 적재하는 단위는 페이지 단위로 한다.
- 장점!
  - 하나의 세그먼트 크기를 페이지 크기의 배수가 되게 함으로써 세그먼트 기법의 외부조각 문제를 해결!
  - 세그먼트 단위로 하여 공유나 보안에 효과적이기 떄문에 페이징 기법의 약점을 해결!



### 6.1 주소 변환 방법

- 외부의 세그먼트 테이블, 내부의 페이지 테이블 두단계 사용
- 하나의 세그먼트가 여러개 페이지로 구성되어, 각 세그먼트마다 페이지 테이블을 가지게 됨(2단계 페이지 테이블과 유사)
- <세그먼트 번호, 오프셋> 으로 논리 -> 물리 바꾸기
  1. 세그먼트 테이블[세그먼트 번호] 로 항목에 접근
  2.  세그먼트 테이블[세그먼트 번호] 에는 `세그먼트 길이`, 그 세그먼트의 `페이지 테이블 시작 주소`가 있음
  3. 유효성 검사
     - if 페이지 테이블 시작 + 오프셋 > 세그먼트 테이블 길이 ?
     - 더 크면 유효하지 않음 -> 다른 프로세스 침범
     - 작으면 OK -> 오프셋을 상위, 하위로 나눔
  4. `상위 비트`는 세그먼트 내의 `페이지 번호`로 사용 / `하위 비트`는 페이지 내의 `변위`로 사용
  5. 페이지 테이블 시작 주소 + 상위비트(페이지 번호) = 물리적 메모리의 프레임 위치
  6. 물리적 메모리의 위치 + 하위 비트(변위) = 물리 메모리 주소









# 🚩요약 & 생각 해 보기

> 아래 내용의 이름만 보고 내용을 설명할 수 있으면 참 좋을 것 같습니다. 상반되는 개념이나 장단점이 꽤나 명확해서 차이점, 공통점 위주로 봐도 좋습니다.



(1) 주소 바인딩 방법 3가지

- 컴파일 타임 바인딩
- 로드 타임 바인딩
- 실행 시간 바인딩



(2) 메모리 관련 용어

- 동적 로딩
- 동적 연결
- 중첩
- 스와핑
- 동적 로딩 vs 중첩⭐



(3) 물리적 메모리 할당 방식

- 연속 할당
  - 고정 분할 방식
  - 가변 분할 방식
- 불연속 할당
  - 페이징(EAT⭐, TLB)
  - 세그멘테이션
  - 페이지드 세그멘테이션
    - 장점, 보완점⭐



(4) 각 기법별 정의/장단점/내외부 조각 생성 여부