[컴퓨터시스템구조 CSA 제3장 Part-1](https://youtu.be/zhqTXXhHAQg?list=PLc8fQ-m7b1hD4jqccMlfQpWgDVdalXFbH)

## [제 3장 Part-1](https://youtu.be/zhqTXXhHAQg?list=PLc8fQ-m7b1hD4jqccMlfQpWgDVdalXFbH)

### 데이터의 종류 (Data Types)

- 컴퓨터 레지스터에서 쓰이는 데이터의 종류
  - 산술 연산용 숫자(Numeric)
  - 데이터 처리용 영문자(Alpha)
  - 특수 목적용 기호(Special) - !, @, $, ...
- 진수와 진법
  - radix: 진법의 기수에 해당(10, 2, 8, 16, ...)
  - 8진수
    - 736.4 = 7 * 8^2 + 3 * 8^1 + 6 * 8^0 + 4 * 8^-1
  - 16진수
    - F3 = 15 * 16^1 + 3 * 16^0 = 243

- 2진화 8진수 - 2진수를 세 자리로 끊어 읽으면 8진수
- 2진화 16진수 - 2진수를 네 자리로 끊어 읽으면 16진수
- 2진화 10진수 - 0에서 9까지를 이진수 네 자리로 표현하고, 이를 나열하여 수를 표현(일반적인 십진수의 이진수 표현과는 다름)
  - ex) 9 = 1001 이면 99 = 1001 1001
  - ex) 8 = 1000, 7 = 0111 이면 87 = 1000 0111

![캡처](C:\Users\multicampus\Desktop\Warrrrrr-CS\4. 컴퓨터구조\chapter03\3장-데이터의-표현(유성호).assets\캡처.PNG)



- 영숫자(AlphaNumeric)의 표시
  - ASCII Code: 7비트 (+1 parity bit) - 아스키 코드의 규칙을 알고 외워보려고 해봐라. (굳이?)
    - A = 100 0001
    - B = 100 0010
    - ...
  - EBCDIC Code: 16비트, IBM 인터널 코드
  - UniCode: 16비트, 32비트

- 모스부호
- Flag Signal

## [제 3장 Part-2](https://youtu.be/LsJ7KvKW8kY?list=PLc8fQ-m7b1hD4jqccMlfQpWgDVdalXFbH)

### 보수 (Complements)

- 어떤 진법의 기수(radix)값에 대응하는 역 값(reverse)
- 컴퓨터는 더하기 밖에 할 줄 모르므로 뺄셈을 덧셈으로 바꿔서 계산하고, 이때 사용하는 것이 보수이다.
- r진법에는 r의 보수와 r-1 보수가 있다. 예를 들어, 10진법에는 10의 보수와 9의 보수가 있고, 2진법에는 2의 보수와 1의 보수가 있다.
- r-1 의 보수 체계
  - 9's complement: 어떤 숫자 N이 주어지면 N의 각 자리숫자를 9에서 뺀 것과 동일
    - ex) N=12389 => **9의 보수** = 99999 - 12389 = 87610
  - 1's complement: 어떤 숫자 N이 주어지면 N의 각 자리숫자를 1에서 뺀 것과 동일
    - ex) N=0001111 => **1의 보수** = 1111111 - 0001111 = 1110000
    - 단순히 각 자리수의 1과 0을 바꿔놓은 것과 같다.
- r 의 보수 체계: 어떤 숫자 N이 주어지면 숫자 N을 제일 큰 자리수에서 올림한 수에서 뺀 것
  - 10's complement
    - ex) N=12389 => 1만을 올림하면 10만 => **10의 보수** = 100000 - 12389 = 87611
  - 2's complement
    - ex) N=0001111 => 10000000 - 0001111 = 1110001
    - 1의 보수에 1을 더하는 방법으로 구하는 것이 더 쉽다.

위의 방법으로 구한 **r의 보수**는 뺄셈에 사용할 수 있다. 예를 들어, 600-529를 계산한다고 해보자.

```
= 600 + (-529)
= 600 + 471 // <= 보수 구한 것, 1000-529 = 471 or 999-529 + 1 = 471
= 1071 // 뺄셈에서 올림수는 나오지 않으므로 버려야 한다.
=> 071
답: 71
```

뺄셈을 못한다면서 보수 구할 때 뺄셈을 쓰고 있는데..2진법을 보면 뺄셈을 사용하지 않고 보수를 구하게 된다.

예를 들어 1110010(2) - 1011001(2) 을 계산한다고 해보자.

```
= 1110010 + (-1011001)
= 1110010 + (0100111) // <= 보수 구한 것, 각 숫자의 1을 0으로, 0을 1로 바꾼 후 1을 더함(1의 보수 + 1)

ex) 1011001의 보수 = 0100110 + 1 = 0100111

= 10011001 // 계산 결과, 자리수가 늘어났으므로 늘어난 자리수는 버린다.
=> 0011001(2진수)
=> 25(10진수)
```



### 고정 소수점 표현 (Fixed Point Representation)

- 주로 정수 표현시 사용

  - 최우측(Least Significant Bit)에 소수점 자리가 위치하는 경우 정수이다.

- 소수를 표현하려면 16bit의 경우 중간 지점에 소수점이 위치해야 하지만 일반적으로 이렇게 사용하지 않는다.

- 고정 소수점 ~= 정수 라고 생각하면 편하다. (정확한 개념은 아님)

- -14 라는 정수를 표현하는 방법

  - MSB(Most Significant Bit, 가장 왼쪽)로 부호 표현
  - 양수는 MSB -> 0, 음수는 MSB -> 1
  - 부호 절대값 표현 방식 -> `1 0001110`
  - 1의 보수로 표현 -> `1 1110001`
  - 2의 보수로 표현 -> `1 1110010`
    - 대부분의 컴퓨터와 CPU에서 사용(intel, AMD, Zilog, ...)

- 오버 플로우(Overflow)가 발생할 수 있다.

  - N자리의 두 수를 더하여 N+1자리의 결과가 발생하였을 때, 정해진 레지스터의 비트수를 초과하면 레지스터에 저장된 연산 결과값은 잘못된 값으로 저장된다. 

  - 오버 플로우가 발생하는지 여부를 미리 확인하여 **인터럽트 또는 에러 처리**한다.

    - MSB의 두 캐리(올림) 비트의 값이 서로 다르면 오버플로우

    ![캡처2](C:\Users\multicampus\Desktop\Warrrrrr-CS\4. 컴퓨터구조\chapter03\3장-데이터의-표현(유성호).assets\캡처2.PNG)
    
    왼쪽 그림에서 가장 왼쪽 비트를 합하면 올림값이 0이고, 그 다음 비트를 합하면 올림값이 1이다.
    
    오른쪽 그림에서 가장 왼쪽 비트를 합하면 올림값이 1이고, 그 다음 비트를 합하면 올림값이 0이다.
    
    이렇게 두 올림값이 서로 다르면 오버플로우가 발생한다.



### 부동 소수점 표현 (Floating Point Representation)

- IEEE 754 를 따름
- 수를 가수와 지수로 표현
- 가수(mantissa): 분수, 정수값 표시
- 지수(component): 십진/이진 소수점 위치를 표시
- 부호비트 / 지수부 / 가수부  순으로 부동소수점 표현을 한다. 

![캡처3](C:\Users\multicampus\Desktop\Warrrrrr-CS\4. 컴퓨터구조\chapter03\3장-데이터의-표현(유성호).assets\캡처3.PNG)

[참고](https://smeffect.tistory.com/entry/IEEE-754-%ED%91%9C%EC%A4%80-32%EB%B9%84%ED%8A%B8-%EB%B6%80%EB%8F%99%EC%86%8C%EC%88%98%EC%A0%90-%ED%91%9C%ED%98%84)

예를 들어 14.35를 32비트 부동 소수점으로 표현한다고 해보자.

14를 이진수 변환하면 1110이고, 0.35를 이진수로 변환하면 0101100110011001...이다. (방법이 있음)

따라서 14.35는 이진수로 1110.010110011001100...이다.

이 값을 부동소수점 표현방식으로 바꾸어보면,

1. 양수이므로 부호비트는 0

2. 가수부와 지수부로 나누어 보면 1.11001011001100... * (2^3) 으로, 

   가수는 1.11001011001100, 지수는 3이다.

3. 우선 지수를 위한 8비트가 먼저 나오는데, 지수가 음수일수도 있기 때문에 8비트로 나타낼 수 있는 수의 중간 지점인 127을 기준으로 127보다 작으면 음수, 127보다 크면 양수인 것으로 간주한다.

   따라서 지수가 3이라고 해서 00000011 을 저장하는게 아니라 기준값이 되는 127을 더한 값을 저장한다.

   127 + 3 = 130 = 10000010 이므로 지수부 8비트에 저장되는 값의 형태는 1000 0010 이다.

4. 다음으로 가수를 위한 23비트가 남아있다. 그런데 가수는 앞서 살펴본 바와 같이 맨 처음 소수점을 찍기 전의 숫자는 1이 나올 수 밖에 없으므로 이 맨 처음의 숫자는 생략하고 나머지 부분만 저장해준다. 이렇게 하면 1비트를 더 저장할 수 있는 이점이 생겨 더 정확한 수 표현이 가능해진다.

   따라서 가수부 23비트에 저장되는 값은 1100 1011 0011 0011 0011 001... 이다.

5. 하나로 합쳐보면 14.35는 32비트 부동소수점 표현으로

   **0 1000 0010 1100 1011 0011 0011 0011 001**  이다.



가수부의 비트 수가 많아질수록 더 정확한 값을 구할 수 있지만(해상도 ↑) 메모리를 불필요하게 많이 사용하게 될 수도 있다. 계산해야 하는 숫자가 

C언어 - 타입으로 정수 자료형인 short(16비트), long(32비트) 을 쓴다고 해서 실수를 표현하지 못하는 것은 아니다.



## [제 3장 Part-3](https://youtu.be/2mcFeoA3Vuk?list=PLc8fQ-m7b1hD4jqccMlfQpWgDVdalXFbH)

### 기타 이진 코드 (Other Binary Codes)

![캡처4](C:\Users\multicampus\Desktop\Warrrrrr-CS\4. 컴퓨터구조\chapter03\3장-데이터의-표현(유성호).assets\캡처4.PNG)



### 에러 검출 코드 (Error Detection Codes)

- Parity bit
  - 데이터가 레지스터 - 메모리, 혹은 통신 등으로 전달될 때 외부 잡음 등에 의해 데이터가 변조되는 에러가 발생하는데, 이러한 에러가 발생했는지 알기 위해 Parity bit을 사용한다.
  - 전달하는 데이터에서 0의 개수가 홀수개면 odd parity bit = 1, even parity bit = 0
  - 0의 개수가 짝수개면 odd parity bit = 0, even parity bit = 1
  - parity 둘 중 하나를 써서 데이터를 전송하면, 수신측에서 데이터를 받아서 0의 개수를 세어보고 parity가 송신측의 것과 같은지 확인한다.
  - 0의 개수가 다르면 송신측과 수신측의 parity가 다르므로 중간에 에러가 발생한 것이다.