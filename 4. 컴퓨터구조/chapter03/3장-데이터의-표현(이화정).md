[컴퓨터시스템구조 CSA 제3장 Part-1](https://youtu.be/zhqTXXhHAQg?list=PLc8fQ-m7b1hD4jqccMlfQpWgDVdalXFbH)

## [제 3장 Part-1](https://youtu.be/zhqTXXhHAQg?list=PLc8fQ-m7b1hD4jqccMlfQpWgDVdalXFbH)

### 데이터의 종류 (Data Types) 

> 컴퓨터 개발의 원래 목적은 숫자 계산이었다. 따라서 숫자형 데이터가 가장 중요하다

#### 컴퓨터 레지스터에서 쓰이는 데이터의 종류

- 산술 연산용 숫자(Numeric)

- 데이터 처리용 영문자(Alpha) 

  - ASCII Code : 7bits (+1 parity bit)

    ![image-20210721101609877](3장-데이터의-표현.assets/image-20210721101609877-1626830172424.png)

  - EBCDIC Code  : 16bits, IBM internal code, Extended BCD 

  - UniCode : 16bits/32bits, 7bit의 아스키 코드를 확장시킨 개념

    ![image-20210721101829654](3장-데이터의-표현.assets/image-20210721101829654.png)

- 특수 목적용 기호(Special) : `!` , `@`, `$`...

#### 진수와 진법

- radix : 진법의 기수에 해당 (10, 2, 8, 16 ...)

- 10진수

- 2진수

- 8진수 

- 16진수

- 2진화 8진수 (Octal)

  ![image-20210721101106514](3장-데이터의-표현.assets/image-20210721101106514-1626829869630.png)

- 2진화 16진수 (Hexadecimal)

  ![image-20210721101130436](3장-데이터의-표현.assets/image-20210721101130436-1626829892225.png)

- 2진화 10진수 (BCD)

  ![image-20210721101142752](3장-데이터의-표현.assets/image-20210721101142752-1626829904537.png)



#### Special Communication Data

- Morse Code
- Flag Signal (Red/White flags)



## [제 3장 Part-2](https://youtu.be/LsJ7KvKW8kY?list=PLc8fQ-m7b1hD4jqccMlfQpWgDVdalXFbH)

### 보수 (Complements)

- 정의 : 진법의 기수 r에 대응하는 역(reverse)값

  - (r-1)의 보수 체계
    - N = 12389, 9의 보수 : 99999 - 12389 = 87610
    - N = 0001111, 1의 보수 : 1111111 - 0001111 = 1110000
  - r의 보수 체계
    - 10의 보수 : 100000 - 12389 = 87611
    - 2의 보수 : 1000000 - 0001111 = 1110001

- 뺄셈과 논리 계산에 사용 

- 컴퓨터는 모든 연산을 덧셈으로 바꿔서 한다, 이 때 보수 연산을 통해 원하는 값으로 바꾼다

  ![image-20210721174910490](3장-데이터의-표현.assets/image-20210721174910490-1626857352080.png)

- 위의 방법으로 구한 **r의 보수**는 뺄셈에 사용할 수 있다. 예를 들어, 600-529를 계산한다고 해보자.

  ```
  = 600 + (-529)
  = 600 + 471 // <= 보수 구한 것, 1000-529 = 471 or 999-529 + 1 = 471
  = 1071 // 뺄셈에서 올림수는 나오지 않으므로 버려야 한다.
  => 071
  답: 71
  ```

  

### 고정 소수점 표현 (Fixed Point Representation)

- 고정소수점 : 소수점이 없는 수 = 정수

- 소수점의 위치를 결정하여 숫자를 표현하는 방식 

- 레지스터 비트에 소수점 위치를 표시

  ![image-20210721175240235](3장-데이터의-표현.assets/image-20210721175240235.png)

- 최우측(LSB)에 소수점 자리 위치

##### 정수의 표현 (-14)

- MSB로 부호 표현
- 양수는 MSB 0, 음수는 MSB 1
- 부호 절대값 표현(`signed magnitude`) 1 0001110
- 부호화된 1의 보수(`signed 1'`s complement`) 1 1110001
- 부호화된 2의 보수 (`signed 2'`s complement`) 1 1110010 : 대부분의 컴퓨터에서 사용

##### 산술 가산

​	![image-20210721195606418](3장-데이터의-표현.assets/image-20210721195606418-1626864967877.png)

##### 산술 감산

![image-20210721195616683](3장-데이터의-표현.assets/image-20210721195616683.png)

##### overflow

- N 자리의 두 수를 더하여 N + 1 자리의 합이 발생하였을 때 발생
- 정해진 레지스터의 비트 수로 인한 문제 
  - 실제 상황에서는 발생하지 않으나 정해진 비트 수 내에서만 연산이 가능한 컴퓨터에서 발생
- 처리 방법 : 오버플로우 발생을 미리 확인하여 연산을 처리하지 않고 인터럽트 또는 에러 처리
  - 오버플로우 발생 확인 법 : MSB의 두 캐리 비트의 값이 서로 다르면 오버플로우



### 부동 소수점 표현 (Floating Point Representation)

- 실수

- 수를 가수와 지수로 표현

  - 가수 : 분수, 정수값 표시
  - 지수 : 십진/이진 소수점 위치를 표시

- 부호비트 / 지수부/ 가수부 순으로 부동 소수점 표현을 한다![캡처3](3장-데이터의-표현(이화정).assets/캡처3.PNG)

  예를 들어 14.35를 32비트 부동 소수점으로 표현한다고 해보자.

  14를 이진수 변환하면 1110이고, 0.35를 이진수로 변환하면 0101100110011001...이다. (방법이 있음)

  따라서 14.35는 이진수로 1110.010110011001100...이다.

  이 값을 부동소수점 표현방식으로 바꾸어보면,

  1. 양수이므로 부호비트는 0

  2. 가수부와 지수부로 나누어 보면 1.11001011001100... * (2^3) 으로, 

     가수는 1.11001011001100, 지수는 3이다.

  3. 우선 지수를 위한 8비트가 먼저 나오는데, 지수가 음수일수도 있기 때문에 8비트로 나타낼 수 있는 수의 중간 지점인 127을 기준으로 127보다 작으면 음수, 127보다 크면 양수인 것으로 간주한다.

     따라서 지수가 3이라고 해서 00000011 을 저장하는게 아니라 기준값이 되는 127을 더한 값을 저장한다.

     127 + 3 = 130 = 10000010 이므로 지수부 8비트에 저장되는 값의 형태는 1000 0010 이다.

  4. 다음으로 가수를 위한 23비트가 남아있다. 그런데 가수는 앞서 살펴본 바와 같이 맨 처음 소수점을 찍기 전의 숫자는 1이 나올 수 밖에 없으므로 이 맨 처음의 숫자는 생략하고 나머지 부분만 저장해준다. 이렇게 하면 1비트를 더 저장할 수 있는 이점이 생겨 더 정확한 수 표현이 가능해진다.

     따라서 가수부 23비트에 저장되는 값은 1100 1011 0011 0011 0011 001... 이다.

  5. 하나로 합쳐보면 14.35는 32비트 부동소수점 표현으로

     **0 1000 0010 1100 1011 0011 0011 0011 001**  이다.

     

## [제 3장 Part-3](https://youtu.be/2mcFeoA3Vuk?list=PLc8fQ-m7b1hD4jqccMlfQpWgDVdalXFbH)

### 기타 이진 코드 (Other Binary Codes)

- ![캡처4](3장-데이터의-표현(이화정).assets/캡처4.PNG)

### 에러 검출 코드 (Error Detection Codes)

- Parity bit
  - 데이터가 레지스터 - 메모리, 혹은 통신 등으로 전달될 때 외부 잡음 등에 의해 데이터가 변조되는 에러가 발생하는데, 이러한 에러가 발생했는지 알기 위해 Parity bit을 사용한다.
  - 전달하는 데이터에서 0의 개수가 홀수개면 odd parity bit = 1, even parity bit = 0
  - 0의 개수가 짝수개면 odd parity bit = 0, even parity bit = 1
  - parity 둘 중 하나를 써서 데이터를 전송하면, 수신측에서 데이터를 받아서 0의 개수를 세어보고 parity가 송신측의 것과 같은지 확인한다.
  - 0의 개수가 다르면 송신측과 수신측의 parity가 다르므로 중간에 에러가 발생한 것이다.