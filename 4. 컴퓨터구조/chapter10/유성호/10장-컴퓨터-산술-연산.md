영상: [컴퓨터시스템구조 CSA10 Part-1](https://youtu.be/JEqQn9lMpDY?list=PLc8fQ-m7b1hD4jqccMlfQpWgDVdalXFbH)

## [제 10장 Part-1](https://youtu.be/JEqQn9lMpDY?list=PLc8fQ-m7b1hD4jqccMlfQpWgDVdalXFbH)

### 덧셈과 뺄셈 (Addition and Substraction)

컴퓨터가 다루는 데이터 형식은 크게 네 가지가 있다.

- 부호절대값으로 표시된 고정소수점 이진 데이터(34: 0 0100010)
- 부호화된 2의 보수로 표현되는 고정소수점 이진 데이터(-34: 1 1011110) - 주로 사용
- 부동소수점 이진 데이터(0.34*10^2: 0 0100010 00000010) - 주로 사용
- 이진화된 십진수(BCD) 데이터(1264: 0001 0010 0110 1000)

우선 첫 번째로 부호절대값으로 표시된 데이터를 이용한 덧셈과 뺄셈을 알아보자. 

<img src="C:\Users\multicampus\Desktop\cs-study\컴퓨터-구조\10장-컴퓨터-산술-연산.assets\캡처.PNG" alt="캡처" style="zoom: 200%;" />

B register가 있고, 그 앞에 부호 레지스터가 있다. 보수를 만들어주는ㄴ complementer, 병렬 덧셈기 Parallel adder가 있다. 기본 컴퓨터는 16비트 데이터를 다루기 때문에 Parallel adder는 16비트이다. 연산 결과는 A register에 저장된다. (accumulator)

연산은 부호를 먼저 결정해야 하며, 그 후 절댓값을 더하거나 빼는 순으로 진행한다.

연산할 두 수의 부호가 같은 경우 어떤 연산 결과가 나올지는 자명하다.

**연산할 두 수의 부호가 다른 경우 A와 B를 서로 비교해서 연산 결과의 부호를 결정한다.**



<img src="C:\Users\multicampus\Desktop\cs-study\컴퓨터-구조\10장-컴퓨터-산술-연산.assets\캡처2.PNG" alt="캡처2" style="zoom:150%;" />

덧셈과 뺄셈의 하드웨어 알고리즘을 살펴보자.

덧셈의 경우 만약 부호가 같다면 오버플로우가 발생할 수 있다. (부호비트가 침범되어 발생)

- 우선 계산할 두 수의 부호가 같으면 Exclusive OR이 0이고, 다르면 Exclusive OR이 1이다. 따라서 XOR을 이용하여 1이 나오면 오버플로우 처리를 할 필요가 없다.
- XOR을 이용하여 0이 나온 경우 A와 B를 더한 다음 AVF 값에 E를(Parallel adder의 결과) 넣는다. 만약 오버플로우가 생겼다면 E값이 1로 들어갈 것이다. => 하드웨어가 오버플로우를 처리하기 위한 동작을 한다.
-  XOR을 이용하여 1이 나온 경우 EA <= A + (B의 2의 보수) 를 계산하고 AVF 값(오버플로우 여부)에는 오버플로우가 발생할리 없으므로 0을 넣어준다.
- 만약 E 플립플롭의 값이 1이라면 A가 B보다 큰 경우, 0이라면 A가 B보다 작은 경우이다. 각 경우를 나눠 결과를 계산한다.

뺄셈도 위와 동일한 프로세스를 거친다.



다음으로 부호가 있는 2의 보수 데이터를 이용한 덧셈과 뺄셈을 알아보자.

<img src="C:\Users\multicampus\Desktop\cs-study\컴퓨터-구조\10장-컴퓨터-산술-연산.assets\캡처3.PNG" alt="캡처3" style="zoom:150%;" />

하드웨어가 훨씬 간단해졌다. AC 레지스터, BR 레지스터, 보수처리기, parallel adder가 있다.

만약 덧셈을 한다면

- 덧셈할 값은 AC에, 더할 값을 BR에 넣고 더한다. 그 결과 오버플로우가 났다면(E 플립플롭이 1이다) V에 1을 넣는다. 뺄셈도 마찬가지로 AC - BR을 해서 오버플로우가 났으면 V에 1을 넣고 끝낸다.

- 따로 부호 확인을 안해도 오버플로우가 발생할 수 있는 상황이 명확하다.

## [제 10장 Part-2](https://youtu.be/PCesRDdlbCU?list=PLc8fQ-m7b1hD4jqccMlfQpWgDVdalXFbH)

### 곱셈 알고리즘 (Multiplication Algorithm)

곱셈의 원리

- 연속적인 시프트와 덧셈으로 구성
- 23*19 = 23을 19번 더함

이런 곱셈을 하기 위한 하드웨어 요소는 뭘까?

- Accumulator (AC)
- Multiplicand를 담는 B 레지스터
- Multiplier를 담는 Q 레지스터
- 자릿수를 따지는 시퀀스 카운터(SC)
- 덥셈에 사용하는 parallel adder

곱셈의 경우 비트 오버플로우가 쉽게 발생한다. 비트를 초과하는 값을 모두 담기 위해 AC와 Q를 합쳐서 사용하기도 한다. (레지스터가 충분히 많으면 그럴 필요x)



알아둬야 하는 것 - 어떤 하드웨어 요소가 덧셈, 뺄셈, 곱셈에서 사용되는가? => 기사시험에 나옴

![캡처4](C:\Users\multicampus\Desktop\cs-study\컴퓨터-구조\10장-컴퓨터-산술-연산.assets\캡처4.PNG)



![캡처5](C:\Users\multicampus\Desktop\cs-study\컴퓨터-구조\10장-컴퓨터-산술-연산.assets\캡처5.PNG)

계산 과정을 나타낸 그림, 결과는 EAQ가 된다.

 Shift right EAQ라고 써 있는데, 이는 A 레지스터와 Q 레지스터에 shift가 있고, E 플리플롭을 오른쪽으로 옮기는 동작으로 이루어져 있다.

![캡처6](C:\Users\multicampus\Desktop\cs-study\컴퓨터-구조\10장-컴퓨터-산술-연산.assets\캡처6.PNG)



![캡처7](C:\Users\multicampus\Desktop\cs-study\컴퓨터-구조\10장-컴퓨터-산술-연산.assets\캡처7.PNG)

- Booth의 곱셈 알고리즘

  - 비트의 1이 연속되는 부분을 일일이 계산하는게 아니라 2^(k+1) - 2^m로 나타낸다.
  - 아래 그림은 Booth 알고리즘의 수행 예다.
  - 무슨 말인지는 잘 모르겠는데 그냥 이런 알고리즘이 있더라..

  

![캡처8](C:\Users\multicampus\Desktop\cs-study\컴퓨터-구조\10장-컴퓨터-산술-연산.assets\캡처8.PNG)

곱셈을 하는 방법에 레지스터와 adder를 쓰는 방법이 있었는데, 위 그림은 논리곱을 논리회로로 만들어 결과를 얻는 배열 승산기이다. (Array Multiplier)

이렇게 하면 별도의 하드웨어를 만들어야 하고 복잡하지만 속도가 조금 더 빠르다. 복붙으로 구성할 수 있어 많이 어려운건 아니지만 남들한텐 어렵다고 하고 비싸게 만들어주자 ^^

## [제 10장 Part-3](https://youtu.be/uOPhmVrvrm4?list=PLc8fQ-m7b1hD4jqccMlfQpWgDVdalXFbH)

### 나눗셈 알고리즘 (Division Algorithm)

나눗셈을 하기위한 하드웨어는 곱셈과 같고, 기본적으로 뺄셈을 반복하는 것이다.

A도 16비트고 B도 16비트인데 A가 더 작은 값이고 B로 나누려고 하는 상황이라면 총 17비트 이상이 필요하여 오버플로우가 발생할 수 있다. 이게 무슨 소리냐...

175를 3으로 나누면 몫이 58이고 나머지가 1임을 손쉽게 알 수 있다. 이를 컴퓨터로 하게 되면,

- 맨 처음에 175의 맨 앞에 있는 1은 3으로 나눌 수 없고, 뒤에 있는 7까지 표현이 되어 17~ 이 되면 비로소 나눌 수 있다. 이진법에서도 마찬가지로 이렇게 비트를 하나 더 써야 나누기 값을 알 수 있는 경우가 있고, 이게 오버플로우가 된다.
- 나눌 대상이 더 작은 경우 문제가 발생할 수 있다는 뜻

![캡처](C:\Users\multicampus\Desktop\cs-study\컴퓨터-구조\10장-컴퓨터-산술-연산.assets\캡처-16286783878931.PNG)

뺄셈을 하는 과정은 아래와 같다. 필요하면 공부해보자.

![캡처2](C:\Users\multicampus\Desktop\cs-study\컴퓨터-구조\10장-컴퓨터-산술-연산.assets\캡처2-16286785059262.PNG)



### 부동 소수점 산술 연산 (Floating-Point Arthmetic Operations)

![캡처3](C:\Users\multicampus\Desktop\cs-study\컴퓨터-구조\10장-컴퓨터-산술-연산.assets\캡처3-16286785842183.PNG)

M은 가수, r은 지수를 표현하는 부분이다. 십진법으로 생각해보면, 예를 들어 17.54를 M*r^n 형태로 표현하면

1.754 * 10^1 이 된다. 컴퓨터에서는 당연히 십진법이 아니라 이진법이고, 우리가 배우는 것은 이진법을 얘기한다.



부동소수점을 표현하기 위해서는 레지스터 A, B, Q 뿐만 아니라 **지수를 표현하는 추가적인 레지스터(b, a, q)**가 필요하며, 따라서 정수를 계산하는 레지스터보다 길 수밖에 없다. 이렇게 지수부분을 연산한다는 점만 다르고 정수 연산과 비슷하다.



덧셈이나 뺄셈을 한다고 가정할 때, 가장 먼저 해야하는 부분은 지수나 AC 값이 0인지 아닌지 조사해야 한다. 지수가 0이면 답이 바로 나올 것이고, AC값이 0이면 그냥 정수 연산하듯이 하면 된다. 이 두 가지를 제외하면, 둘 다 실수라는 뜻이고, a와 b를 비교하여 연산을 시작한다. 계산을 하고 나면 정규화를 하여 0.xxx로 표현되기 만든다.



곱셈이나 나눗셈도 같다.   

![캡처4](C:\Users\multicampus\Desktop\cs-study\컴퓨터-구조\10장-컴퓨터-산술-연산.assets\캡처4-16286792938504.PNG)

나눗셈은 바이어스라는 값이 있고, 이 값을 기준으로 결과를 표현한다.

예를 들어 계산 결과가 2의 10승이고, bias가 128이면 a <- a + bias 에서 뒤 a에 들어가는 값은 138이 된다.

**왜 바이어스값을 쓰냐**면, 지수에 **양수와 음수**값이 있기 때문이다. 우리가 정수를 쓸 때는 부호비트가 앞에 있는데, 아까 알아본 지수가 들어가는 비트에는 부호비트가 없는 대신에 bias를 이용한다.

예를 들어 지수부분인 b 레지스터가 8비트이고, 따라서 최댓값이 256일 때, 128이 기준이 되어서 2^0으로 표현한다. 2^-3은 125, 2^6은 134로 표현한다.





### 십진 산술 장치 (Decimal Arithmetic Unit)

BCD 가산기, BCD 감산기 얘기를 하시는데 무슨 말인지 모르겠다.



### 십진 산술 연산 (Decimal Arthmetic Operations)

![캡처10](C:\Users\multicampus\Desktop\cs-study\컴퓨터-구조\10장-컴퓨터-산술-연산.assets\캡처10.PNG)

3 가지의 십진 연산 장치를 소개하고 있다.



- 첫 번째는 각 자리수를 병렬로 연산(동시에)하여 carry가 발생하면 앞자리수로 넘겨주는 방식이다.  (한 번에 연산)
- 두 번째는 adder가 하나로, 직렬로 연산하여 자릿수별로 순서대로 연산을 하고, carry가 발생하면 다음 연산에 이용 (총 세 번 연산)
- 세 번째는 한 비트씩 연산하는 방식으로, 캐리가 발생하면 다음 비트에 반영된다. (열 두번 연산)

당연히 제일 빠른건 첫 번째인데, 어떤 경우에 어떤 하드웨어를 쓸지는 거의 가이드라인이 잡혀있다.



![캡처11](C:\Users\multicampus\Desktop\cs-study\컴퓨터-구조\10장-컴퓨터-산술-연산.assets\캡처11.PNG)

십진 곱셈은 BCD 감산기를 사용한다는 점만 알아두자.

실제 인텔같은데서 십진 연산 전용 하드웨어를 갖추는 경우는 없다. 그래도 활용도는 높으니까 알아두자.

